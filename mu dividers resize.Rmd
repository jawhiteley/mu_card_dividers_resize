---
output: 
  pdf_document:
    keep_tex: FALSE
geometry: margin=1cm
params:
  pdf_file:    # name of pdf file to process in the `input` directory.  Leave blank to process **all** pdf files in the directory.
  extract_images: FALSE  # run the R script to extract images (everything at once)?  Set to FALSE to run it manually (or to save time if you already ran it and have the outputs)
  div_height: 72 # in mm: Height of dividers (originals are 66.4 mm, which is too short for sleeved cards)
  div_width:  92 # in mm: Width of dividers (originals are 91.9 mm, including a 1 px wide black border)
  border:   0.25 # in mm: Thickness of borders around dividers (added to the _outside_ of dividers: not included in the dimensions above)
# DIMENSIONS:
# Dividers in original file are 3.620 in wide x 2.613 in tall (91.9 x 66.4 mm; approximately 92 x 66.5 mm in practice).
# Cards themselves are 63 x 88 mm (standard poker size).  Therefore original dividers only project about 3-4 mm above the top of cards.
# Sleeves vary in size, but I have found that premium sleeves (e.g., Dragon Shield) are about as wide as the original dividers are tall.  
# Dragon Shield (one of the largest) specifications are up to 92.5 x 66.5 mm (https://daviscardsandgames.com/products/dragon-shield-clear-matte-sleeves-standard-size)
# Therefore, a reasonable target is 92 mm wide (about the same as large premium sleeves, maybe even a bit less) and 71-72 mm tall, to allow 4-5 mm above sleeves.
# Except that my insert from TinkeringPaws only has a vertical clearance of 70 mm (2.76 in), and the core box only has 68 mm (2.68 in) clearance. 
# 70 mm fits in the core box at an angle, but I might not want to go much taller.  Or use 72 mm (2.83 in) for output here, and just cut mine to 70. ;)
# BORDERS: 
# Original uses 1 pixel non-overlapping, so 1 px around the outside and 2 pixels between each divider, 
#  in an image 1500 x 1200 px that is 254 mm wide on the page ~= 0.3387 mm between dividers?
# 0.25 mm feels close, and a good compromise between being too thin and too thick.
  img_dir: pdf_images
header-includes: |
  \graphicspath{{./`r params$img_dir`/}}
  \pagenumbering{gobble}  % remove page numbers
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

## PARAMETERS - will be used by `mu dividers resize.r` if run from here.
pdf_file <- params$pdf_file
img_dir  <- params$img_dir

library(knitr)

## Working Directory: all paths are relative to here
# When compiling an R Markdown document (using render()), the default working directory is automatically the same directory as the file itself. :)
# https://bookdown.org/yihui/rmarkdown-cookbook/working-directory.html
```
```{r extract, include=FALSE, eval=params$extract_images}
# If you want to do everything here in one step, set the value of the 'extract_images' parameter to 'TRUE' in the in the document header.
# If you already ran the r script and want to skip directly to output, set the value of the 'extract_images' parameter to 'FALSE' in the in the document header.

# Run the external script to extract graphics from the input pdf.
# All the necessary parameters are set in that script. 
# This document does not rely on running this script during compilation, in case you want to run the script first, then produce the output in 2 steps (see comments above).
# Running the external script here just allows you to do it all in one step.
source("mu dividers resize.r", local = knitr::knit_global())
```

```{=latex}
% LaTeX setup - some of this could go in the (YAML) header (header-includes), but there's quite a bit, and this works.

% PARAMETERS: Dimensions (inherited from document parameters: `params` R object)
\def\DivWidth{`r params$div_width`mm}       % Width of each divider
\def\DivHeight{`r params$div_height`mm}     % Height of each divider
\setlength{\fboxrule}{`r params$border`mm}  % width of border around each divider
\setlength{\fboxsep}{0mm}    % space separating border from contents (set to 0 for a tight border)

% re-define \includegraphics command to set desired size and border: the image will be automatically sized to fit the width, flush with the top-left (aspect ratio is preserved by default)
\let\includegraphicsOG\includegraphics
\renewcommand*{\includegraphics}[2][]{\fbox{\parbox[t][\DivHeight]{\DivWidth}{\includegraphicsOG[#1]{#2}}}}

% control spacing around graphics
\setlength{\lineskip}{-\fboxrule}   % remove veritcal space between dividers (negative width of the border, so borders from adjacent lines overlap)

\raggedright    % force left alignment (aka 'raggedright') instead of fully justified
% Set the inter-word spacing to the same as the border width, but negative, so that they overlap.
%   For whatever reason, line and page breaks still work fine. 
%   Alternatively, these lengths can be set very small, and `\hspace{-\fboxrule}` added to the end of the \includegraphics re-definition above.
\setlength{\spaceskip}{-\fboxrule}
%\setlength{\xspaceskip}{-\fboxrule}
```

```{r graphics, echo=FALSE}
# get list of (png) files: 1 file per divider
img_files <- list.files(img_dir, '.png$', recursive = FALSE, full.names = TRUE)
# loop over the list and apply include_graphics() (vectorized!), which should use the custom command defined above.
include_graphics(img_files)
```
